from direct.fsm.FSM import FSM
from direct.actor.Actor import Actor

from direct.interval.MetaInterval import Sequence,Parallel
from direct.interval.FunctionInterval import Func,Wait

from direct.showbase.ShowBase import ShowBase


from panda3d.core import NodePath

from guimockup import PlayerHud , Timer
from direct.task import Task

from direct.showbase import DirectObject

class InputHandler(DirectObject.DirectObject):
    def __init__(self,keymap,side):
        #lets start by creating a mapping a key to a number, so we get independant of keyboards, controllers, cpu and networking.
        #this code, still is keyboard dependant is it maps keys to an event number (the index of the key)
        #using ["a","b","c"] , will make key a the event 0, b event 1 and so on.
        #given my godlike power to define indices at will...
        #i hearby delcare index  1 to 4 will map to up,down,left, right.
        #given the rotation this might end up messed.. a bit
        #further i declare thet event 5 shall be punch, 6 kick, 7 defense
        #index 42 shall play a cute animation on cute characters and some raw and macho-like animation on raw-macho like chars
        #dont dare to disobey.
        #negative event numbers map to key-lift events . so we cant use event 0 as -0 == 0 , stuffing "" as index 0
        keymap.insert(0,"")
        #keymap = ["","arrow_up","arrow_down","arrow_left","arrow_right","1","2","3"] #added button 1,2 and 3 , totaly at will. wanna change your keymap, change this array
        self.side = side
        self.keystatus = set()
        for index,key in enumerate(keymap):
            self.accept(key,self.setKey,[index,1] )
            self.accept(key+"-up",self.setKey,[index,0])
        self.events = [] #will store the combos event numbers and state requests

        
    def setKey(self,eventnr,SetOrClear):
        #swap left-right depending on the player side, for the left player, left will be left. aah .. confusing. someone else should fix it .. once it gets troublesome
        if self.side and eventnr == 3:
            eventnr = 4
        elif self.side and eventnr ==4:
            eventnr = 3
            
        if SetOrClear:
            self.keystatus.add(eventnr)
        else:
            self.keystatus.remove(eventnr)
        for event in self.events:
               ##set if the key goes down and the combo matches  OR     if the key goes up with no other combo specified.    
               #like used when defending, or walking , walking states transition via idle.
            if  (event[0] == eventnr and event[1] == self.keystatus) or  ( event[0]==-eventnr  )   :  
                event[2][0].request(event[2][1])   
    
    def pollEvents(self,eventsToTest=[1,2,3,4]):
        eventsToTest=set(eventsToTest)        
        
        
        for event in self.events:
               ##set if the key goes down and the combo matches  OR     if the key goes up with no other combo specified.    
               #like used when defending, or walking , walking states transition via idle.
            if  (event[0] in eventsToTest& self.keystatus) and  ( len(event[1])==1  )   :  
                event[2][0].request(event[2][1])
        
        
        
    def clearMapping(self):
        self.events = []
    
    def mapEvent(self,fsm,triggerevent,action,activeevents=[]):

        activeevents = set(activeevents)
        activeevents.add(triggerevent)
        self.events.append([triggerevent,activeevents,[fsm,action]])

from panda3d.core import BitMask32

class Fighter():
    def __init__(self,characterPath , callOnDeath , side , keymap, name = None):
        #side indicates if the player is on the left or right side.
        
        self.side = side
        
        self.wins = 0 #counting won rounds, a doubleko/draw counts as win for both.
        
        self.callOnDeath = callOnDeath
        self.statusBitMask = BitMask32()
        self.defenseBitMask = BitMask32()    #active defense parts get a 1
        #the attack bitmask is generated by the fsm and passed to attack right away
        
        if not name:
            name = "player"+str(1+bool(side))
        self.fighterNP = render.attachNewNode(name)
        
        self.fsm = FighterFSM(name)
        self.fsm.setup(self,keymap,self.side)
        self.healthBar = PlayerHud(side, name )
        self.prepareFighter()
    
    def prepareFighter(self):
        taskMgr.remove("player"+str(self.side))
        self.speed = (0,0)
        self.fsm.forceTransition("Idle")
        print "preparing for new round"
        self.health= 100
        self.healthBar.setHealth(self.health)
        self.healthBar.setRoundIndicator('V'*self.wins)
        
        if self.side:
            self.fighterNP.setX(5)
        else:
            self.fighterNP.setX(-5)
            
        taskMgr.add(self.__playertask__, "player"+str(self.side))
    
    def setStatusBitMask(self,bitmask):
        self.statusBitMask = bitmask
        
    def setDefenseBitMask(self,bitmask):
        self.defenseBitMask = bitmask 
   
    #getters and setters are a bit stupid here. properties from python 3 would be nice
    def fighterWin(self):
        #request a win-anim from the fsm if there are any , be sure to filter out that one if the player is KO
        self.wins += 1
        self.healthBar.setRoundIndicator('V'*self.wins)
    
    def getWins(self):
        return self.wins   
    
    def getHealth(self):
        return self.health
        
    def getNP(self):
        return self.fighterNP

    def setOpponent(self,opponent):
        self.opponent = opponent
        self.fighterNP.lookAt(self.opponent.getNP())
   
    def attack(self,attackBitMask,attackrange,damageHit,damageDodge=0): #those variables will be supplied by the fsm states later on. 
                                                             #function is pretty redundant... for structure only, and for early days
        print 'attacking'
        self.opponent.getAttacked(attackBitMask,attackrange,damageHit,damageDodge)
        
    def getAttacked(self,attackBitMask,attackrange,damageHit,damageDodge=0): #the equivalent
        print "getting attacked!!"
        if self.health<0:
            return 0 #catch the event that the player is dead already. the forceTransition Hit made trouble
        dist = self.fighterNP.getY(self.opponent.getNP()) 
        if  dist > attackrange or dist < 0   :
            #attack misses due to out of range.
            print "missed due to long distance"
            return 0 

        if self.statusBitMask & attackBitMask == 0: # attak misses cause the player avoided it. went low or so.
            print "attack missed, no bitmask match"
            return 0
            
        print (self.defenseBitMask & attackBitMask).getWord()    
        if (self.defenseBitMask & attackBitMask).getWord():
            
            print "attack got dodged"
            self.health -= damageDodge
            self.healthBar.setHealth(self.health)
            #set health down by damageDodge if any.
            #set fsm so it goes into the right anim and so on
            return 1 #hit,... but blocked so no combos 
            
        else:
            print "hit it!"
            self.health -= damageHit
            self.healthBar.setHealth(self.health)
            self.fsm.forceTransition("Hit")
            #draw health
            #set fsm state.
            print self.health
            return 2 #in ya face .... smash.
    
    def setSpeed(self,x,y):
        self.speed = (x,y)
         #player motion should go here i guess, if the fsm provide any smarter way to do that disregard this definition.
        #checking for players health. couldbe done in getAttacked but that would propably break the last animation on the attacker side.
        #setx, sety 
        
    def __playertask__(self,task):
        if self.health <= 0:
            taskMgr.remove("ko-task")
            taskMgr.doMethodLater(0.2,self.callOnDeath,name="ko-task") #allow 0.2 seconds for double ko
            self.fsm.forceTransition("Ko")
            return
        self.fighterNP.setX(self.fighterNP,self.speed[1]*globalClock.getDt())
        self.fighterNP.setY(self.fighterNP,self.speed[0]*globalClock.getDt()) 
        return Task.cont


class FighterFSM(FSM):  #inherits from direct.fsm.FSM
                    ##this class has to be written for each character in the game 
                    ####unfortunately that much coding per char is required until we can autogenerate based on artists input
                    ## i am not sure where to put the fighter actor. logically it belongs to the fighter class, but the fsm does a lot more with it.
                    ## guess it will end up in the fsm as this is the file created for each fighter individually.
                    ## or if we should inherit Fighter from FSM and simply stuff everything in there wich would be bad cause we copy all shared code around
    def mapEvent(self,eventNr,event,activeevents=[]):
        """
        convenience function
        """
        self.inputHandler.mapEvent(self,eventNr,event,activeevents)
        
    def clearMapping(self):
        """
        another convenience function
        """
        self.inputHandler.clearMapping()
   
    def setSBM(self,bitmask):
        """
        yet another convenience function, sets the status bit mask
        """
        self.fighterinstance.setStatusBitMask(bitmask)
        
    def setDBM(self,bitmask):
        """
        aaand yet another convenience function, sets the defense bit mask
        """
        self.fighterinstance.setDefenseBitMask(bitmask)    
            
    def attack(self,attackBitMask,attackrange,damageHit,damageDodge=0):
        """
        more convenience function, this one attacks the opponent
        """
        self.fighterinstance.attack(attackBitMask,attackrange,damageHit,damageDodge)
    
    def setup(self,FighterClassInstance,keymap,side):
        
        self.fighter = Actor('./stickfigure', 
                                        {
                                          'rpunch'      :'stickfigure-r_punch',
                                          'lpunch'      :'stickfigure-l_punch',
                                          'hit'         :'stickfigure-hit'    ,
                                          'defense'     :'stickfigure-defense',
                                          'idle'        :'stickfigure-idle'   ,
                                          'kick'        :'stickfigure-kick'   ,
                                          'run'         :'stickfigure-run'    ,
                                          'step'        :'stickfigure-step'   ,
                                          'ko'          :'stickfigure-ko'     ,
                                          'round-kick'  :'stickfigure-round-kick'

                                        })
        #model was rotated the wrong way in blender.. darn fixing it
        self.fighter.setH(180)
        self.fighter.flattenMedium()
                                      
        self.fighter.reparentTo(render)
        
        #self.fighter = FighterClassInstance.ActorNodePath #so we can directly play and loop the animation there.
        self.fighterinstance = FighterClassInstance
        self.fighter.reparentTo(self.fighterinstance.getNP())
        self.inputHandler = InputHandler(keymap,side) #instance of the InputHandler class ... we definetly need custom keymaps to pass at this point
        self.activeInterval = None #we will store our active sequence,parallel or interval here, so we can easily clean it up 
                                  #(altho we could go with naming them all the same,too. wich would be even more elegant)
        self.transitionTimer = None #usually holds a sequence like sequence(Wait(time),self.request('nextstate'))
        self.request("Idle")
    
    
    #----------
    def enterKo(self):
        self.clearMapping()
        self.fighter.play("ko")
    def filterKo(self,request,args):
        #this blocks the fsm. but will be forced to idle by the fighter class
        return
    def exitKo(self):
        pass    
    #-----------
    def enterHit(self):
        self.clearMapping()
        self.fighter.play("hit")
        self.transitionTimer= Sequence(Wait(self.fighter.getDuration()), Func(self.request,"Idle" ) )
        self.transitionTimer.start()
   
    def exitHit(self):
        self.clearMapping()
        self.transitionTimer = None
        self.activeInterval = None
    #------------
    def enterIdle(self):
        #self.fighterinstance.setSpeed(0,0)
        newBitMask = BitMask32()
        newBitMask.setRange(0,3)
        self.setSBM(newBitMask)
        self.fighter.loop("idle")
        self.mapEvent( 3, "Step")
        self.mapEvent( 4, "Run")
        self.mapEvent( 5, "RPunch" )
        self.mapEvent( 5, "LPunch", [2])
        self.mapEvent( 6, "Kick" )  
        self.mapEvent( 7, "Defense" )
        Func(self.inputHandler.pollEvents).start() #slightly hacky but we cant call that WITHIN the transition of entering idle. so it will be called next frame.
        #doesnt look logic but saves craploads of uncool code, trust me
        print "entered idle"
        
    def exitIdle(self):
        #self.fighterinstance.setSpeed(0,0) #cant hurt
        self.transitionTimer = None
        self.activeInterval = None
        self.clearMapping()
    
    
     #-------------------------
    def enterStep(self):
        self.fighter.loop("step")
        self.fighter.setPlayRate(-1,"step")
        self.fighterinstance.setSpeed(-4.69 ,0)
        self.mapEvent(-3, "Idle")
        self.mapEvent( 5, "RPunch",[3]) #we would not hit unless we add the key. might need a fix^^
        self.mapEvent( 6, "Kick"  ,[3] )  
    
    def exitStep(self):
        self.fighter.stop()
        self.fighterinstance.setSpeed(0 ,0)
        self.clearMapping()
    
    #-------------------------
    def enterRun(self):
        self.fighter.loop("run")
        self.fighterinstance.setSpeed(20.23 ,0)
        self.mapEvent(-4, "Idle")
        self.mapEvent( 5, "RPunch",[4]) #we would not hit unless we add the key. might need a fix^^
        self.mapEvent( 6, "Kick"  ,[4] )  
    
    def exitRun(self):
        self.fighter.stop()
        self.fighterinstance.setSpeed(0 ,0)
        self.clearMapping()
    
    #-------------------------
    #example of a punch, wich default returns to idle, if no buttons are pressed. also blocks button presses/requests until sort befor the end. 
    #at the end it is possible to transition to any legal state we defined earlier 
    def enterRPunch(self):
        print "entering rpunch"
        #self.fighterinstance.setSpeed(0,0) #just for illustration
        self.fighter.stop()
        self.fighter.play('rpunch')
        self.transitionTimer= Sequence(Wait(self.fighter.getDuration()), Func(self.request,"Idle" ) )
        self.transitionTimer.start() 
        attackMask = BitMask32()
        attackMask.setBit(2)
        self.activeTimer = Sequence( Wait(0.12),
                                     Func(self.attack,attackMask,6,5 ) #attack, bitmasks, range, damage
                                   )
        self.activeTimer.start()
        
        self.mapEvent(5,"LPunch") #allows us to combo a punch followed by a kick.

    def filterRPunch(self,request,args):
        if self.transitionTimer.getT() > self.transitionTimer.getDuration()-0.2 :  #allow player to hit the next strike 0.2 to 0 seconds befor the animation finished
            print "combo r"
            return request

    def exitRPunch(self):
        print "exiting rpunch"
        self.transitionTimer = None
        self.activeInterval = None
        self.clearMapping()
        pass
        

    #---------------------------
   
    def enterLPunch(self):
        print "entering lpunch"
        #self.fighterinstance.setSpeed(0,0) #just for illustration
        self.fighter.stop()
        self.fighter.play('lpunch')
        self.transitionTimer= Sequence(Wait(self.fighter.getDuration()), Func(self.request,"Idle" ) )
        self.transitionTimer.start()
        attackMask = BitMask32()
        attackMask.setBit(2)
        self.activeTimer = Sequence( Wait(0.12),
                                     Func(self.attack,attackMask,6,5 ) #attack, bitmasks, range, damage
                                   )
        self.activeTimer.start()
        self.mapEvent(5,"RPunch")

    def filterLPunch(self,request,args):
        if self.transitionTimer.getT() > self.transitionTimer.getDuration()-0.2 :  #allow player to hit the next strike 0.2 to 0 seconds befor the animation finished
            print "combo l"
            return request

    def exitLPunch(self):
        print "exiting lpunch"
        self.transitionTimer = None
        self.activeInterval = None
        self.clearMapping()
        
    #--------------------------------    
        
    def enterKick(self):
        print "entering kick"
        self.fighter.stop()
        self.fighter.play('kick')
        self.transitionTimer= Sequence(Wait(self.fighter.getDuration()), Func(self.request,"Idle" ) )
        self.transitionTimer.start()
        attackMask = BitMask32()
        attackMask.setBit(2)
        self.activeTimer = Sequence( Wait(0.16),
                                     Func(self.attack,attackMask,6,10,2 ) #attack, bitmasks, range, damage, dodgedamage
                                   )
        self.activeTimer.start()

    def filterKick(self,request,args):
        if self.transitionTimer.getT() > self.transitionTimer.getDuration()-0.2 : 
            print "kick end"
            return request

    def exitLPunch(self):
        print "exiting kick"
        self.transitionTimer = None
        self.activeInterval = None
        self.clearMapping()
        
    #-----------------  

        
    def enterDefense(self):
        newBitMask = BitMask32()
        newBitMask.setBit(1)
        newBitMask.setBit(2)
        self.setDBM(newBitMask)
        
        print "entering Defense"
        self.fighter.stop()
        self.fighter.loop('defense')
        self.mapEvent(-7,"Idle")


    def exitDefense(self):
        newBitMask = BitMask32()
        self.setDBM(newBitMask)
        print "exiting Defense"
        self.transitionTimer = None
        self.activeInterval = None
        self.clearMapping()
        
    #-----------------       


class Match():
    def __init__(self, Character1, Character2, keymapPlayer1,keymapPlayer2,roundTime=10,name1="Player1",name2="Player2"):
        ###character 1 and 2 are strings pointing to the assets with the character. will be delivered by the character-selection screen.
        ### till we have the selection screen, hardcode or default them.
        
        #arena = #... load the arena here, be sure to set propper bitmasks on the floor and ring-out geometry
        
        self.player1 = Fighter(Character1, self.roundEnd, 0, keymapPlayer1 ,name=name1 )
        self.player2 = Fighter(Character2, self.roundEnd, 1, keymapPlayer2 ,name=name2 )
        
        self.player1.setOpponent(self.player2)
        self.player2.setOpponent(self.player1)
        
        self.roundTime=roundTime
        self.timer = Timer(self.roundEnd)
        self.timer.setTime(roundTime)
        self.timer.start()

                
    def roundEnd(self,task=None):
        self.timer.stop()
        #double ko would require a variable like roundOver.
        #short delay to allow double ko. 
        if self.player1.getHealth()<0 and self.player2.getHealth() < 0:
            #double knockout.
            self.player1.fighterWin()
            self.player2.fighterWin()
            
        elif self.player2.getHealth() > self.player1.getHealth():
            self.player2.fighterWin()
            #player2 wins
        elif self.player2.getHealth() < self.player1.getHealth():
            self.player1.fighterWin()
        else:
            #both players with the same health??? W T F ??
            pass
            
        #in case of double time-up we need to disable inputs of the player till the next round starts.
        Sequence(Wait(5), Func(self.player1.prepareFighter )).start()
        Sequence(Wait(5), Func(self.player2.prepareFighter )).start()
        self.timer.setTime(self.roundTime)
        Sequence(Wait(5), Func(self.timer.start)).start()
        
        print self.player1.getWins(),self.player2.getWins()
        if self.player1.getWins() >=3 and self.player2.getWins() >=3:
            #match ended in a draw
            self.endMatch()
        elif self.player1.getWins() >=3:
            #player1 wins
            self.endMatch()
        elif self.player2.getWins() >=3 :
            #player2 wins
            self.endMatch()
        #update the round-wins gui. display guistuff, play win animation on chars, do whatever you like..
        #reset the char healt,reset the positions and fsm states, then let the fun go on.
        #eventually clear the round-end variable.
        #if one player has 3 wins. end match
 
    def endMatch(self):
        print "match ended!"
        #preferably show splashscreen till the menu has loaded
        #remove players and the arena.

base = ShowBase()
Match(None,None,["f","t","r","d","x","v","l"],["arrow_up","arrow_down","arrow_left","arrow_right","1","2","3"])

base.disableMouse()
base.camera.setY(-30)
base.camera.setZ(5)
base.run() 
