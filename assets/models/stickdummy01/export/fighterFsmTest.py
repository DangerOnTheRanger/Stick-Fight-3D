from direct.fsm.FSM import FSM
from direct.actor.Actor import Actor

from direct.interval.MetaInterval import Sequence,Parallel
from direct.interval.FunctionInterval import Func,Wait

from direct.showbase.ShowBase import ShowBase
from direct.showbase import DirectObject

from panda3d.core import NodePath

from guimockup import PlayerHud
from direct.task import Task

class inputHandler(DirectObject.DirectObject):
    def __init__(self,keymap,side):
        #lets start by creating a mapping a key to a number, so we get independant of keyboards, controllers, cpu and networking.
        #this code, still is keyboard dependant is it maps keys to an event number (the index of the key)
        #using ["a","b","c"] , will make key a the event 0, b event 1 and so on.
        #given my godlike power to define indices at will...
        #i hearby delcare index  1 to 4 will map to up,down,left, right.
        #given the rotation this might end up messed.. a bit
        #further i declare thet event 5 shall be punch, 6 kick, 7 defense
        #index 42 shall play a cute animation on cute characters and some raw and macho-like animation on raw-macho like chars
        #dont dare to disobey.
        #negative event numbers map to key-lift events . so we cant use event 0 as -0 == 0 , stuffing "" as index 0
        keymap.insert(0,"")
        #keymap = ["","arrow_up","arrow_down","arrow_left","arrow_right","1","2","3"] #added button 1,2 and 3 , totaly at will. wanna change your keymap, change this array
        self.side = side
        self.keystatus = set()
        for index,key in enumerate(keymap):
            self.accept(key,self.setKey,[index,1] )
            self.accept(key+"-up",self.setKey,[index,0])
        self.events = [] #will store the combos event numbers and state requests

        
    def setKey(self,eventnr,SetOrClear):
        #swap left-right depending on the player side, for the left player, left will be left. aah .. confusing. someone else should fix it .. once it gets troublesome
        if self.side and eventnr == 3:
            eventnr = 4
        elif self.side and eventnr ==4:
            eventnr = 3
            
        if SetOrClear:
            self.keystatus.add(eventnr)
        else:
            self.keystatus.remove(eventnr)
        for event in self.events:
               ##set if the key goes down and the combo matches  OR     if the key goes up with no other combo specified.    
               #like used when defending, or walking , walking states transition via idle.
            if  (event[0] == eventnr and event[1] == self.keystatus) or  ( event[0]==-eventnr  )   :  
                event[2][0].request(event[2][1])   
    
    def pollEvents(self,eventsToTest=[1,2,3,4]):
        eventsToTest=set(eventsToTest)        
        
        
        for event in self.events:
               ##set if the key goes down and the combo matches  OR     if the key goes up with no other combo specified.    
               #like used when defending, or walking , walking states transition via idle.
            if  (event[0] in eventsToTest& self.keystatus) and  ( len(event[1])==1  )   :  
                event[2][0].request(event[2][1])
        
        
        
    def clearMapping(self):
        self.events = []
    
    def mapEvent(self,fsm,triggerevent,action,activeevents=[]):

        activeevents = set(activeevents)
        activeevents.add(triggerevent)
        self.events.append([triggerevent,activeevents,[fsm,action]])

from panda3d.core import BitMask32
class Fighter():
    def __init__(self,characterPath , callOnDeath , side , keymap, name = None):
        #side indicates if the player is on the left or right side.
        
        self.side = side
        self.speed = (0,0)
        self.wins = 0 #counting won rounds, a doubleko/draw counts as win for both.
        
        self.callOnDeath = callOnDeath
        self.statusBitMask = BitMask32()
        self.defenseBitMask = BitMask32()    #active defense parts get a 1
        #the attack bitmask is generated by the fsm and passed to attack right away
        
        if not name:
            name = "player"+str(1+bool(side))
        self.fighterNP = render.attachNewNode(name)
        
        self.health= 100
        self.healthBar = PlayerHud(side, name )
        self.healthBar.setHealth(self.health)
        self.healthBar.setRoundIndicator(' ')
        self.fsm = FighterFSM(name)
        self.fsm.setup(self,keymap,self.side)
        
        if side:
            self.fighterNP.setX(5)
        else:
            self.fighterNP.setX(-5)
        
        taskMgr.add(self.__playertask__, "player task")
    
    def setStatusBitMask(self,bitmask):
        self.statusBitMask = bitmask
        
    def setDefenseBitMask(self,bitmask):
        self.defenseBitMask = bitmask 
         
    def getNP(self):
        return self.fighterNP
        
    def setOpponent(self,opponent):
        self.opponent = opponent
        self.fighterNP.lookAt(self.opponent.getNP())
   
    def attack(self,attackBitMask,attackrange,damageHit,damageDodge=0): #those variables will be supplied by the fsm states later on. 
                                                             #function is pretty redundant... for structure only, and for early days
        print 'attacking'
        self.opponent.getAttacked(attackBitMask,attackrange,damageHit,damageDodge)
        
    def getAttacked(self,attackBitMask,attackrange,damageHit,damageDodge=0): #the equivalent
        print "getting attacked!!"
        dist = self.fighterNP.getY(self.opponent.getNP()) 
        if  dist > attackrange or dist < 0   :
            #attack misses due to out of range.
            print "missed due to long distance"
            return 0 

        if self.statusBitMask & attackBitMask == 0: # attak misses cause the player avoided it. went low or so.
            print "attack missed, no bitmask match"
            return 0
            
        print (self.defenseBitMask & attackBitMask).getWord()    
        if (self.defenseBitMask & attackBitMask).getWord():
            
            print "attack got dodged"
            self.health -= damageDodge
            self.healthBar.setHealth(self.health)
            #set health down by damageDodge if any.
            #set fsm so it goes into the right anim and so on
            return 1 #hit,... but blocked so no combos 
            
        else:
            print "hit it!"
            self.health -= damageHit
            self.healthBar.setHealth(self.health)
            self.fsm.forceTransition("Hit")
            #draw health
            #set fsm state.
            print self.health
            return 2 #in ya face .... smash.
    
    def setSpeed(self,x,y):
        self.speed = (x,y)
    

        #player motion should go here i guess, if the fsm provide any smarter way to do that disregard this definition.
        #checking for players health. couldbe done in getAttacked but that would propably break the last animation on the attacker side.
        
        
        #setx, sety 
    def __playertask__(self,task):
        if self.health <= 0:
            if self.callOnDeath:
                self.callOnDeath()
        self.fighterNP.setX(self.fighterNP,self.speed[1]*globalClock.getDt())
        self.fighterNP.setY(self.fighterNP,self.speed[0]*globalClock.getDt()) 
        return Task.cont

class FighterFSM(FSM):  #inherits from direct.fsm.FSM
                    ##this class has to be written for each character in the game 
                    ####unfortunately that much coding per char is required until we can autogenerate based on artists input
                    ## i am not sure where to put the fighter actor. logically it belongs to the fighter class, but the fsm does a lot more with it.
                    ## guess it will end up in the fsm as this is the file created for each fighter individually.
                    ## or if we should inherit Fighter from FSM and simply stuff everything in there wich would be bad cause we copy all shared code around
    def mapEvent(self,eventNr,event,activeevents=[]):
        """
        convenience function
        """
        self.inputHandler.mapEvent(self,eventNr,event,activeevents)
        
    def clearMapping(self):
        """
        another convenience function
        """
        self.inputHandler.clearMapping()
   
    def setSBM(self,bitmask):
        """
        yet another convenience function, sets the status bit mask
        """
        self.fighterinstance.setStatusBitMask(bitmask)
        
    def setDBM(self,bitmask):
        """
        aaand yet another convenience function, sets the defense bit mask
        """
        self.fighterinstance.setDefenseBitMask(bitmask)    
            
    def attack(self,attackBitMask,attackrange,damageHit,damageDodge=0):
        """
        more convenience function, this one attacks the opponent
        """
        self.fighterinstance.attack(attackBitMask,attackrange,damageHit,damageDodge)
    
    def setup(self,FighterClassInstance,keymap,side):
        
        self.fighter = Actor('./stickfigure', 
                                        {
                                          'rpunch'      :'stickfigure-r_punch',
                                          'lpunch'      :'stickfigure-l_punch',
                                          'hit'         :'stickfigure-hit'    ,
                                          'defense'     :'stickfigure-defense',
                                          'idle'        :'stickfigure-idle'   ,
                                          'kick'        :'stickfigure-kick'   ,
                                          'run'         :'stickfigure-run'    ,
                                          'step'        :'stickfigure-step'   ,
                                          'ko'          :'stickfigure-ko'     ,
                                          'round-kick'  :'stickfigure-round-kick'

                                        })
        #model was rotated the wrong way in blender.. darn fixing it
        self.fighter.setH(180)
        self.fighter.flattenMedium()
                                      
        self.fighter.reparentTo(render)
        
        #self.fighter = FighterClassInstance.ActorNodePath #so we can directly play and loop the animation there.
        self.fighterinstance = FighterClassInstance
        self.fighter.reparentTo(self.fighterinstance.getNP())
        self.inputHandler = inputHandler(keymap,side) #instance of the InputHandler class ... we definetly need custom keymaps to pass at this point
        self.activeInterval = None #we will store our active sequence,parallel or interval here, so we can easily clean it up 
                                  #(altho we could go with naming them all the same,too. wich would be even more elegant)
        self.transitionTimer = None #usually holds a sequence like sequence(Wait(time),self.request('nextstate'))
        self.request("Idle")
    
    def enterHit(self):
        self.clearMapping()
        self.fighter.play("hit")
        self.transitionTimer= Sequence(Wait(self.fighter.getDuration()), Func(self.request,"Idle" ) )
        self.transitionTimer.start()
   
    def exitHit(self):
        self.clearMapping()
        self.transitionTimer = None
        self.activeInterval = None

    def enterIdle(self):
        #self.fighterinstance.setSpeed(0,0)
        newBitMask = BitMask32()
        newBitMask.setRange(0,3)
        self.setSBM(newBitMask)
        self.fighter.loop("idle")
        self.mapEvent( 3, "Step")
        self.mapEvent( 4, "Run")
        self.mapEvent( 5, "RPunch" )
        self.mapEvent( 5, "LPunch", [2])
        self.mapEvent( 6, "Kick" )  
        self.mapEvent( 7, "Defense" )
        Func(self.inputHandler.pollEvents).start() #slightly hacky but we cant call that WITHIN the transition of entering idle. so it will be called next frame.
        #doesnt look logic but saves craploads of uncool code, trust me
        print "entered idle"
        
    def exitIdle(self):
        #self.fighterinstance.setSpeed(0,0) #cant hurt
        self.transitionTimer = None
        self.activeInterval = None
        self.clearMapping()
    
    
     #-------------------------
    def enterStep(self):
        self.fighter.loop("step")
        self.fighter.setPlayRate(-1,"step")
        self.fighterinstance.setSpeed(-4.69 ,0)
        self.mapEvent(-3, "Idle")
        self.mapEvent( 5, "RPunch",[3]) #we would not hit unless we add the key. might need a fix^^
        self.mapEvent( 6, "Kick"  ,[3] )  
    
    def exitStep(self):
        self.fighter.stop()
        self.fighterinstance.setSpeed(0 ,0)
        self.clearMapping()
    
    #-------------------------
    def enterRun(self):
        self.fighter.loop("run")
        self.fighterinstance.setSpeed(20.23 ,0)
        self.mapEvent(-4, "Idle")
        self.mapEvent( 5, "RPunch",[4]) #we would not hit unless we add the key. might need a fix^^
        self.mapEvent( 6, "Kick"  ,[4] )  
    
    def exitRun(self):
        self.fighter.stop()
        self.fighterinstance.setSpeed(0 ,0)
        self.clearMapping()
    
    #-------------------------
    #example of a punch, wich default returns to idle, if no buttons are pressed. also blocks button presses/requests until sort befor the end. 
    #at the end it is possible to transition to any legal state we defined earlier 
    def enterRPunch(self):
        print "entering rpunch"
        #self.fighterinstance.setSpeed(0,0) #just for illustration
        self.fighter.stop()
        self.fighter.play('rpunch')
        self.transitionTimer= Sequence(Wait(self.fighter.getDuration()), Func(self.request,"Idle" ) )
        self.transitionTimer.start() 
        attackMask = BitMask32()
        attackMask.setBit(2)
        self.activeTimer = Sequence( Wait(0.12),
                                     Func(self.attack,attackMask,6,5 ) #attack, bitmasks, range, damage
                                   )
        self.activeTimer.start()
        
        self.mapEvent(5,"LPunch") #allows us to combo a punch followed by a kick.

    def filterRPunch(self,request,args):
        if self.transitionTimer.getT() > self.transitionTimer.getDuration()-0.2 :  #allow player to hit the next strike 0.2 to 0 seconds befor the animation finished
            print "combo r"
            return request

    def exitRPunch(self):
        print "exiting rpunch"
        self.transitionTimer = None
        self.activeInterval = None
        self.clearMapping()
        pass
        

    #---------------------------
   
    def enterLPunch(self):
        print "entering lpunch"
        #self.fighterinstance.setSpeed(0,0) #just for illustration
        self.fighter.stop()
        self.fighter.play('lpunch')
        self.transitionTimer= Sequence(Wait(self.fighter.getDuration()), Func(self.request,"Idle" ) )
        self.transitionTimer.start()
        attackMask = BitMask32()
        attackMask.setBit(2)
        self.activeTimer = Sequence( Wait(0.12),
                                     Func(self.attack,attackMask,6,5 ) #attack, bitmasks, range, damage
                                   )
        self.activeTimer.start()
        self.mapEvent(5,"RPunch")

    def filterLPunch(self,request,args):
        if self.transitionTimer.getT() > self.transitionTimer.getDuration()-0.2 :  #allow player to hit the next strike 0.2 to 0 seconds befor the animation finished
            print "combo l"
            return request

    def exitLPunch(self):
        print "exiting lpunch"
        self.transitionTimer = None
        self.activeInterval = None
        self.clearMapping()
        
    #--------------------------------    
        
    def enterKick(self):
        print "entering kick"
        self.fighter.stop()
        self.fighter.play('kick')
        self.transitionTimer= Sequence(Wait(self.fighter.getDuration()), Func(self.request,"Idle" ) )
        self.transitionTimer.start()
        attackMask = BitMask32()
        attackMask.setBit(2)
        self.activeTimer = Sequence( Wait(0.16),
                                     Func(self.attack,attackMask,6,10,2 ) #attack, bitmasks, range, damage, dodgedamage
                                   )
        self.activeTimer.start()

    def filterKick(self,request,args):
        if self.transitionTimer.getT() > self.transitionTimer.getDuration()-0.2 : 
            print "kick end"
            return request

    def exitLPunch(self):
        print "exiting kick"
        self.transitionTimer = None
        self.activeInterval = None
        self.clearMapping()
        
    #-----------------  

        
    def enterDefense(self):
        newBitMask = BitMask32()
        newBitMask.setBit(1)
        newBitMask.setBit(2)
        self.setDBM(newBitMask)
        
        print "entering Defense"
        self.fighter.stop()
        self.fighter.loop('defense')
        self.mapEvent(-7,"Idle")


    def exitDefense(self):
        newBitMask = BitMask32()
        self.setDBM(newBitMask)
        print "exiting Defense"
        self.transitionTimer = None
        self.activeInterval = None
        self.clearMapping()
        
    #-----------------       


base = ShowBase()
f1 = Fighter(None,None,0,["f","t","r","d","x","v","l"]) #left player
f2 = Fighter(None,None,1,["arrow_up","arrow_down","arrow_left","arrow_right","1","2","3"])
#in case you wonder... i am not using a qwert keyboard layout. it would map to o l k oe q w e using a german keyboard .. use your own ones.

f1.setOpponent(f2)
f2.setOpponent(f1)

base.disableMouse()
base.camera.setY(-30)
base.camera.setZ(5)
base.run() 
